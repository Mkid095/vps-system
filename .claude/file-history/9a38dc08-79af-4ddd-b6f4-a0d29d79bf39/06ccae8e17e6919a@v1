# Filesystem-Coordinated Scheduler - Condensed v1 Plan

## Goal

Add story-level locking to Maven Flow using `flock` to prevent parallel sessions from working on the same story simultaneously.

## Critical Invariants (Load-Bearing)

1. **Only `flow.sh` mutates PRDs** - Workers cannot modify story state
2. **Heartbeat is source of truth** - NOT time-based expiry
3. **PID + heartbeat AND logic** - Both must be valid for lock ownership
4. **Never delete `.lock` files** - Use `flock` exclusive mode for cleanup

## Implementation Checklist

### Phase 1: Core Lock Functions

**Create:** `/home/ken/next-mavens-flow/.claude/lib/lock.sh`

```bash
# Heartbeat configuration (must be defined before use)
FLOW_HEARTBEAT_INTERVAL=60   # Update every 60 seconds
FLOW_HEARTBEAT_TIMEOUT=300   # 5x interval = 5 minutes before lock considered stale

# Get lock path for a story
story_lock_path() {
    local prd_file="$1"
    local story_id="$2"
    local prd_hash=$(echo "$prd_file" | md5sum | cut -d' ' -f1)
    echo ".flow-locks/${prd_hash}-${story_id}.lock"
}

# Find and lock the next available story
# Returns: 0=success, 1=no stories available
# Outputs: PRD file and story ID to stdout
# IMPORTANT: stdout is authoritative only if function exits 0
find_and_lock_story() {
    local session_id="$1"
    local session_pid=$$

    mkdir -p .flow-locks

    for prd in docs/prd-*.json; do
        [ -f "$prd" ] || continue

        while IFS= read -r story_id; do
            local lock_path=$(story_lock_path "$prd" "$story_id")
            local lock_data_path="${lock_path}.data"

            # Try to acquire lock (non-blocking)
            (
                flock -x -n 9 || exit 1

                # CRITICAL: Re-verify story is still incomplete under lock
                # This avoids race conditions where PRD changes between scan and lock
                if ! jq -e ".userStories[] | select(.id==\"$story_id\" and .passes==false)" "$prd" >/dev/null 2>&1; then
                    exit 1
                fi

                # Read existing lock data
                if [ -f "$lock_data_path" ]; then
                    local owner_pid=$(jq -r '.pid // empty' "$lock_data_path" 2>/dev/null)
                    local last_heartbeat=$(jq -r '.lastHeartbeat // 0' "$lock_data_path" 2>/dev/null)
                    local now=$(date +%s)
                    local age=$((now - last_heartbeat))

                    # PID + heartbeat AND logic: BOTH must be valid
                    # Owner is alive only if PID exists AND heartbeat is fresh
                    if [ -n "$owner_pid" ] && kill -0 "$owner_pid" 2>/dev/null && [ "$age" -lt "$FLOW_HEARTBEAT_TIMEOUT" ]; then
                        exit 1  # Lock is valid, owner is alive
                    fi
                    # Owner dead or heartbeat stale - we can take it
                fi

                # Write our lock data
                cat > "$lock_data_path" <<EOF
{
  "sessionId": "$session_id",
  "pid": $session_pid,
  "storyId": "$story_id",
  "prdFile": "$prd",
  "lockedAt": $(date +%s),
  "lastHeartbeat": $(date +%s)
}
EOF

                # Output what we locked
                echo "$prd|$story_id"
                exit 0
            ) 9>"$lock_path"

            if [ $? -eq 0 ]; then
                return 0
            fi
        done < <(jq -r '.userStories[] | select(.passes == false) | .id' "$prd" 2>/dev/null)
    done

    return 1
}

# Unlock a single story (story-scoped, NOT session-scoped)
# Use this on story completion - NOT clear_all_session_locks
unlock_story() {
    local prd="$1"
    local story_id="$2"
    local session_id="$3"

    local lock_path=$(story_lock_path "$prd" "$story_id")
    local lock_data="${lock_path}.data"

    [ -f "$lock_data" ] || return 0

    (
        flock -x 9
        local owner=$(jq -r '.sessionId // empty' "$lock_data" 2>/dev/null)
        [ "$owner" = "$session_id" ] && rm -f "$lock_data"
    ) 9>"$lock_path"
}

# Clear all locks for current session (emergency cleanup only)
# Use this on session abort, NOT on story completion
clear_all_session_locks() {
    local session_id="$1"
    [ -d .flow-locks ] || return 0

    for lock_data in .flow-locks/*.lock.data; do
        [ -f "$lock_data" ] || continue

        local owner_session=$(jq -r '.sessionId // empty' "$lock_data" 2>/dev/null)
        if [ "$owner_session" = "$session_id" ]; then
            local lock_path="${lock_data%.data}"
            # Acquire lock to safely clear data
            (
                flock -x 9
                rm -f "$lock_data"
            ) 9>"$lock_path"
        fi
    done
}

# Update heartbeat for all locks owned by this session
update_session_heartbeats() {
    local session_id="$1"
    [ -d .flow-locks ] || return 0

    for lock_data in .flow-locks/*.lock.data; do
        [ -f "$lock_data" ] || continue

        local owner_session=$(jq -r '.sessionId // empty' "$lock_data" 2>/dev/null)
        if [ "$owner_session" = "$session_id" ]; then
            local lock_path="${lock_data%.data}"
            (
                flock -x 9
                jq --arg now "$(date +%s)" '.lastHeartbeat = ($now | tonumber)' "$lock_data" \
                  > "${lock_data}.tmp" && mv "${lock_data}.tmp" "$lock_data"
            ) 9>"$lock_path"
        fi
    done
}
```

### Phase 2: Heartbeat Loop (Mandatory)

**Modify:** `/home/ken/next-mavens-flow/bin/flow.sh`

Add heartbeat loop in `flow start`:

```bash
flow_start() {
    # ... existing setup ...
    local session_id=$(cat .flow-session)

    # Source lock library (defines FLOW_HEARTBEAT_INTERVAL constant)
    source .claude/lib/lock.sh

    # Start heartbeat loop (mandatory - background)
    (
        while true; do
            sleep "$FLOW_HEARTBEAT_INTERVAL"
            update_session_heartbeats "$session_id"
        done
    ) &
    local heartbeat_pid=$!
    echo $heartbeat_pid > .flow-heartbeat-pid

    # Main iteration loop
    # ... existing iteration logic using find_and_lock_story ...

    # Cleanup heartbeat on exit
    kill $heartbeat_pid 2>/dev/null
    rm -f .flow-heartbeat-pid
}
```

### Phase 3: Modify Story Selection

**Change:** `/home/ken/next-mavens-flow/bin/flow.sh` (lines ~568-721)

Replace existing story scan with:

```bash
# Find and lock next story
if ! result=$(find_and_lock_story "$session_id"); then
    echo "All stories complete or no available stories"
    break
fi

PRD_FILE=$(echo "$result" | cut -d'|' -f1)
STORY_ID=$(echo "$result" | cut -d'|' -f2)

# ... proceed with /flow-work-story ...

# After story completes, unlock THIS STORY ONLY (story-scoped, not session-scoped)
unlock_story "$PRD_FILE" "$STORY_ID" "$session_id"
```

### Phase 4: flow-status Rewrite

**Modify:** `/home/ken/next-mavens-flow/bin/flow-status.sh`

Add lock status display:

```bash
# Must match constants from lock.sh
FLOW_HEARTBEAT_TIMEOUT=300

show_lock_status() {
    [ -d .flow-locks ] || return 0

    echo -e "\n${CYAN}Story Locks:${NC}"

    local found=0
    for lock_data in .flow-locks/*.lock.data; do
        [ -f "$lock_data" ] || continue
        found=1

        local story_id=$(jq -r '.storyId' "$lock_data")
        local session_id=$(jq -r '.sessionId' "$lock_data")
        local pid=$(jq -r '.pid' "$lock_data")
        local locked_at=$(jq -r '.lockedAt' "$lock_data")
        local last_heartbeat=$(jq -r '.lastHeartbeat' "$lock_data")

        local now=$(date +%s)
        local age=$((now - locked_at))
        local heartbeat_age=$((now - last_heartbeat))

        # PID + heartbeat AND logic: BOTH must be valid for "alive"
        # Nested if is WRONG - we need AND condition
        local status="unknown"
        if kill -0 "$pid" 2>/dev/null && [ "$heartbeat_age" -lt "$FLOW_HEARTBEAT_TIMEOUT" ]; then
            status="owner alive"
            icon="${GREEN}ðŸ”’${NC}"
        else
            status="owner dead (reclaimable)"
            icon="${YELLOW}âš ï¸${NC}"
        fi

        local age_str="$((age / 60))m"
        echo -e "  ${icon} ${story_id} - session ${session_id:0:8} - ${status} (${age_str} old)"
    done

    [ $found -eq 0 ] && echo -e "  ${GRAY}No active locks${NC}"
}
```

**NOTE:** Use "owner alive" / "owner dead (reclaimable)" - NEVER say "stale" based on time alone.

### Phase 5: Session Cleanup

**Modify:** `/home/ken/next-mavens-flow/bin/flow.sh` (cleanup function)

```bash
cleanup() {
    local session_id=$(cat .flow-session 2>/dev/null || echo "")

    if [ -n "$session_id" ]; then
        clear_all_session_locks "$session_id"
    fi

    # ... existing cleanup ...
}
```

### Phase 6: Manual Lock Recovery (Simplified)

**Create:** `/home/ken/next-mavens-flow/bin/flow-reset` (already exists, verify it calls cleanup)

The existing `flow reset` should clear all locks via cleanup trap. No separate `flow unlock` needed for v1.

## Files to Modify

| File | Action |
|------|--------|
| **NEW** | `.claude/lib/lock.sh` - Core lock functions |
| Modify | `bin/flow.sh` - Add heartbeat loop, use find_and_lock_story |
| Modify | `bin/flow-status.sh` - Add lock status display |
| Verify | `bin/flow-reset` - Ensure cleanup is called |

## Verification

1. **Test parallel sessions:**
   ```bash
   # Terminal 1
   cd /home/ken/next-mavens-flow
   flow start

   # Terminal 2 (simultaneously)
   cd /home/ken/next-mavens-flow
   flow start  # Should pick different story or wait
   ```

2. **Test lock display:**
   ```bash
   flow status  # Should show active locks with "owner alive" status
   ```

3. **Test recovery:**
   ```bash
   # Kill session mid-story
   pkill -f "flow start"

   # New session should reclaim stale lock
   flow start
   ```

4. **Verify heartbeat:**
   ```bash
   # Check .flow-locks/*.lock.data for lastHeartbeat updates
   watch -n 10 'jq . .flow-locks/*.lock.data'
   ```

## What Was Simplified for v1

| Feature | Status | Reason |
|---------|--------|--------|
| `completedBy` / `completedAt` in locks | **Skipped** | Nice-to-have, not core |
| `flow unlock` command | **Skipped** | `flow reset` + auto-reclaim sufficient |
| `lock_story()` | **Deleted** | Only `find_and_lock_story()` exposed |
| `unlock_story()` | **Kept** | Required for story-scoped unlock on completion |
| Optional heartbeat | **Deleted** | Mandatory loop only |

## Failure Mode Table

| Scenario | Behavior |
|----------|----------|
| Session crashes (kill -9) | Heartbeat ages out, next session reclaims after 300s (5 min) |
| Power loss | Same as crash - self-healing on restart |
| Two sessions start same time | First to flock wins, second gets different story |
| Heartbeat loop dies | Lock ages out, other sessions reclaim after 300s (5 min) |
| Story completes | Only that story's lock is released (not all session locks) |
| Manual `flow reset` | Clears all locks immediately via cleanup |
