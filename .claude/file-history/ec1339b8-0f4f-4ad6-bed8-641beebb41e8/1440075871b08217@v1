// NextMavens Platform - Utility Functions

import { createClient } from '@supabase/supabase-js';
import { createHmac, randomBytes } from 'crypto';
import type { SupabaseConfig } from '../types';

// ====================================================================
// String Utilities
// ====================================================================

/**
 * Convert a string to a URL-safe slug
 */
export function slugify(input: string): string {
  return input
    .toLowerCase()
    .trim()
    .replace(/[^\w\s-]/g, '') // Remove special characters
    .replace(/\s+/g, '-') // Replace spaces with hyphens
    .replace(/-+/g, '-') // Replace multiple hyphens with single
    .substring(0, 50); // Limit length
}

/**
 * Generate a random string
 */
export function generateRandomString(length = 32): string {
  return randomBytes(length).toString('base64').substring(0, length);
}

/**
 * Generate a secure API key
 */
export function generateApiKey(): { key: string; prefix: string } {
  const key = `nm_${randomBytes(32).toString('base64')}`;
  const prefix = key.substring(0, 8);
  return { key, prefix };
}

/**
 * Hash an API key using SHA-256
 */
export function hashApiKey(key: string): string {
  return createHmac('sha256', process.env.API_KEY_SECRET || 'change-me')
    .update(key)
    .digest('hex');
}

// ====================================================================
// Validation Utilities
// ====================================================================

/**
 * Validate email format
 */
export function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

/**
 * Validate phone number (basic international format)
 */
export function isValidPhone(phone: string): boolean {
  const phoneRegex = /^\+?[1-9]\d{1,14}$/;
  return phoneRegex.test(phone.replace(/[\s-()]/g, ''));
}

/**
 * Validate slug format
 */
export function isValidSlug(slug: string): boolean {
  return /^[a-z0-9-]+$/.test(slug) && slug.length >= 2 && slug.length <= 50;
}

// ====================================================================
// Supabase Utilities
// ====================================================================

/**
 * Create a Supabase client for a specific project
 */
export function createProjectClient(config: SupabaseConfig) {
  return createClient(config.url, config.anonKey, {
    db: { schema: config.schema || 'public' },
    auth: {
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: true,
    },
  });
}

/**
 * Create a Supabase admin client (service role)
 */
export function createAdminClient() {
  const url = process.env.SUPABASE_URL || 'http://localhost:8000';
  const key = process.env.SUPABASE_SERVICE_ROLE_KEY || '';

  return createClient(url, key, {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
    },
  });
}

/**
 * Get project database credentials from master database
 */
export async function getProjectCredentials(projectId: string): Promise<{
  db_name: string;
  db_user: string;
  db_password: string;
  db_host: string;
  db_port: number;
} | null> {
  const supabase = createAdminClient();

  const { data, error } = await supabase
    .from('project_databases')
    .select('db_name, db_user, db_password, db_host, db_port')
    .eq('project_id', projectId)
    .single();

  if (error || !data) {
    return null;
  }

  return data as {
    db_name: string;
    db_user: string;
    db_password: string;
    db_host: string;
    db_port: number;
  };
}

/**
 * Build a connection string for a project database
 */
export function buildConnectionString(creds: {
  db_name: string;
  db_user: string;
  db_password: string;
  db_host: string;
  db_port: number;
}): string {
  return `postgres://${encodeURIComponent(creds.db_user)}:${encodeURIComponent(creds.db_password)}@${creds.db_host}:${creds.db_port}/${creds.db_name}`;
}

// ====================================================================
// Webhook Utilities
// ====================================================================

/**
 * Verify webhook signature
 */
export function verifyWebhookSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  const expected = 'sha256=' + createHmac('sha256', secret)
    .update(payload)
    .digest('hex');

  return signature === expected;
}

/**
 * Generate webhook signature
 */
export function generateWebhookSignature(
  payload: string,
  secret: string
): string {
  return 'sha256=' + createHmac('sha256', secret)
    .update(payload)
    .digest('hex');
}

// ====================================================================
// Response Utilities
// ====================================================================

/**
 * Create a success response
 */
export function successResponse<T>(data: T, status = 200) {
  return Response.json({ success: true, data }, { status });
}

/**
 * Create an error response
 */
export function errorResponse(
  code: string,
  message: string,
  status = 400,
  details?: Record<string, unknown>
) {
  return Response.json(
    { error: { code, message, details } },
    { status }
  );
}

// ====================================================================
// Async Utilities
// ====================================================================

/**
 * Sleep for a specified duration
 */
export function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Retry a function with exponential backoff
 */
export async function retry<T>(
  fn: () => Promise<T>,
  maxAttempts = 3,
  baseDelay = 1000
): Promise<T> {
  let lastError: Error | undefined;

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));

      if (attempt < maxAttempts) {
        const delay = baseDelay * Math.pow(2, attempt - 1);
        await sleep(delay);
      }
    }
  }

  throw lastError;
}

// ====================================================================
// Storage Utilities
// ====================================================================

/**
 * Format bytes to human-readable size
 */
export function formatBytes(bytes: number, decimals = 2): string {
  if (bytes === 0) return '0 Bytes';

  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];

  const i = Math.floor(Math.log(bytes) / Math.log(k));

  return `${(bytes / Math.pow(k, i)).toFixed(dm)} ${sizes[i]}`;
}

/**
 * Get disk usage
 */
export async function getDiskUsage(path = '/home/ken'): Promise<{
  used: number;
  total: number;
  percentage: number;
}> {
  try {
    const { exec } = require('child_process');
    const result = await new Promise<string>((resolve, reject) => {
      exec(`df -B1 ${path}`, (error: Error | null, stdout: string) => {
        if (error) reject(error);
        else resolve(stdout);
      });
    });

    const lines = result.split('\n');
    const data = lines[1].split(/\s+/);

    const total = parseInt(data[1], 10);
    const used = parseInt(data[2], 10);

    return {
      used,
      total,
      percentage: Math.round((used / total) * 100),
    };
  } catch (error) {
    console.error('Error getting disk usage:', error);
    return { used: 0, total: 1, percentage: 0 };
  }
}

// ====================================================================
// Phone Number Utilities
// ====================================================================

/**
 * Format phone number to WhatsApp format
 */
export function formatWhatsappNumber(phone: string): string {
  // Remove all non-digit characters
  let cleaned = phone.replace(/\D/g, '');

  // Ensure it starts with country code
  if (!cleaned.startsWith('')) {
    cleaned = cleaned.substring(1);
  }

  // Add @c.us suffix for WhatsApp API
  return `${cleaned}@c.us`;
}

/**
 * Extract phone number from WhatsApp JID
 */
export function extractPhoneNumber(jid: string): string {
  return jid.replace('@c.us', '').replace('@s.whatsapp.net', '');
}
