const express = require('express');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const db = require('./db');

const router = express.Router();
const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-key-change-in-production';
const JWT_EXPIRES_IN = '15m'; // Short-lived access tokens
const REFRESH_TOKEN_EXPIRES_IN = '30d';

// Helper: Set RLS context for database queries
const setRLSContext = async (userId, tenantId) => {
  await db.query('SELECT set_config($1, $2::TEXT, false)', ['request.jwt.claim.user_id', userId]);
  await db.query('SELECT set_config($1, $2::TEXT, false)', ['request.jwt.claim.tenant_id', tenantId]);
};

// Helper: Clear RLS context
const clearRLSContext = async () => {
  await db.query('SELECT set_config($1, NULL, false)', ['request.jwt.claim.user_id']);
  await db.query('SELECT set_config($1, NULL, false)', ['request.jwt.claim.tenant_id']);
};

// Helper: Generate tokens with tenant_id
const generateTokens = (userId, tenantId, role = 'user') => {
  const accessToken = jwt.sign(
    { userId, tenantId, role },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES_IN }
  );
  const refreshToken = jwt.sign(
    { userId, tenantId },
    JWT_SECRET,
    { expiresIn: REFRESH_TOKEN_EXPIRES_IN }
  );
  return { accessToken, refreshToken };
};

// POST /api/auth/create-tenant - Create new tenant with admin user
router.post('/create-tenant', async (req, res) => {
  try {
    const { name, slug, adminEmail, adminPassword, adminName } = req.body;

    if (!name || !slug || !adminEmail || !adminPassword) {
      return res.status(400).json({
        error: 'Name, slug, admin email, and admin password are required'
      });
    }

    // Check if slug is already taken
    const existingTenant = await db.query(
      'SELECT id FROM tenants WHERE slug = $1',
      [slug]
    );

    if (existingTenant.rows.length > 0) {
      return res.status(409).json({ error: 'Tenant slug already exists' });
    }

    // Create tenant using the database function
    const result = await db.query(
      'SELECT * FROM create_tenant($1, $2, $3, $4, $5)',
      [name, slug, adminEmail, adminPassword, adminName || null]
    );

    const tenantData = result.rows[0];

    res.status(201).json({
      tenant: {
        id: tenantData.tenant_id,
        name: tenantData.tenant_name,
        slug: tenantData.slug
      },
      user: {
        id: tenantData.user_id,
        email: adminEmail,
        name: adminName,
        role: 'owner'
      }
    });
  } catch (error) {
    console.error('Create tenant error:', error);
    res.status(500).json({ error: 'Internal server error', details: error.message });
  }
});

// POST /api/auth/signup - Create new user (requires tenant context)
router.post('/signup', async (req, res) => {
  try {
    const { email, password, name, tenantId, tenantSlug } = req.body;

    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password are required' });
    }

    // Check if user already exists (global check)
    const existingUser = await db.query(
      'SELECT id, email FROM users WHERE email = $1',
      [email]
    );

    if (existingUser.rows.length > 0) {
      return res.status(409).json({ error: 'User already exists' });
    }

    // Determine tenant ID
    let targetTenantId = tenantId;

    if (!targetTenantId && tenantSlug) {
      const tenantResult = await db.query(
        'SELECT id FROM tenants WHERE slug = $1',
        [tenantSlug]
      );
      if (tenantResult.rows.length === 0) {
        return res.status(404).json({ error: 'Tenant not found' });
      }
      targetTenantId = tenantResult.rows[0].id;
    }

    if (!targetTenantId) {
      return res.status(400).json({ error: 'Tenant ID or slug is required' });
    }

    // Verify tenant exists
    const tenantCheck = await db.query(
      'SELECT id FROM tenants WHERE id = $1',
      [targetTenantId]
    );

    if (tenantCheck.rows.length === 0) {
      return res.status(404).json({ error: 'Tenant not found' });
    }

    // Hash password
    const saltRounds = 10;
    const password_hash = await bcrypt.hash(password, saltRounds);

    // Create user with tenant_id
    const result = await db.query(
      'INSERT INTO users (email, password_hash, name, tenant_id) VALUES ($1, $2, $3, $4) RETURNING id, email, name, tenant_id, role, created_at',
      [email, password_hash, name || null, targetTenantId]
    );

    const user = result.rows[0];
    const tokens = generateTokens(user.id, user.tenant_id, user.role);

    res.status(201).json({
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        tenant_id: user.tenant_id,
        role: user.role,
        created_at: user.created_at
      },
      ...tokens
    });
  } catch (error) {
    console.error('Signup error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// POST /api/auth/login - Login user
router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password are required' });
    }

    // Find user (without RLS for login)
    const result = await db.query(
      'SELECT * FROM users WHERE email = $1',
      [email]
    );

    if (result.rows.length === 0) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const user = result.rows[0];

    // Verify password
    const isValidPassword = await bcrypt.compare(password, user.password_hash);

    if (!isValidPassword) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Update last login (without RLS context)
    await db.query(
      'UPDATE users SET last_login_at = NOW() WHERE id = $1',
      [user.id]
    );

    // Get tenant info
    const tenantResult = await db.query(
      'SELECT id, name, slug FROM tenants WHERE id = $1',
      [user.tenant_id]
    );

    const tenant = tenantResult.rows[0];

    // Generate tokens with tenant info
    const tokens = generateTokens(user.id, user.tenant_id, user.role);

    res.json({
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        tenant_id: user.tenant_id,
        role: user.role,
        is_verified: user.is_verified,
        created_at: user.created_at
      },
      tenant: tenant ? {
        id: tenant.id,
        name: tenant.name,
        slug: tenant.slug
      } : null,
      ...tokens
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// POST /api/auth/refresh - Refresh access token
router.post('/refresh', async (req, res) => {
  try {
    const { refreshToken } = req.body;

    if (!refreshToken) {
      return res.status(400).json({ error: 'Refresh token is required' });
    }

    // Verify refresh token
    const decoded = jwt.verify(refreshToken, process.env.JWT_SECRET || 'your-super-secret-key-change-in-production');

    // Get user info to verify they still exist and get role
    const result = await db.query(
      'SELECT id, tenant_id, role FROM users WHERE id = $1',
      [decoded.userId]
    );

    if (result.rows.length === 0) {
      return res.status(401).json({ error: 'Invalid refresh token' });
    }

    const user = result.rows[0];
    const tokens = generateTokens(user.id, user.tenant_id, user.role);

    res.json({ ...tokens });
  } catch (error) {
    return res.status(401).json({ error: 'Invalid refresh token' });
  }
});

// GET /api/auth/me - Get current user (protected route)
router.get('/me', async (req, res) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');

    if (!token) {
      return res.status(401).json({ error: 'Access token is required' });
    }

    // Verify token
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'your-super-secret-key-change-in-production');

    // Set RLS context
    await setRLSContext(decoded.userId, decoded.tenantId);

    // Get user from database (with RLS applied)
    const result = await db.query(
      'SELECT id, email, name, tenant_id, role, is_verified, created_at, last_login_at FROM users WHERE id = $1',
      [decoded.userId]
    );

    // Clear RLS context
    await clearRLSContext();

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Get tenant info
    const tenantResult = await db.query(
      'SELECT id, name, slug FROM tenants WHERE id = $1',
      [result.rows[0].tenant_id]
    );

    res.json({
      user: result.rows[0],
      tenant: tenantResult.rows[0] || null
    });
  } catch (error) {
    console.error('Get current user error:', error);
    return res.status(401).json({ error: 'Invalid token' });
  }
});

// GET /api/auth/tenant - Get tenant info
router.get('/tenant', async (req, res) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');

    if (!token) {
      return res.status(401).json({ error: 'Access token is required' });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'your-super-secret-key-change-in-production');

    // Get tenant info
    const result = await db.query(
      'SELECT id, name, slug, settings, created_at FROM tenants WHERE id = $1',
      [decoded.tenantId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Tenant not found' });
    }

    res.json({ tenant: result.rows[0] });
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
});

module.exports = router;
