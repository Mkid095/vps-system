// NextMavens MCP Server API Endpoint
// Implements the Model Context Protocol for self-hosted Supabase

import { NextRequest, NextResponse } from 'next/server';
import { MCP_TOOLS, executeProjectQuery, generateTypescriptTypes } from '@/lib/mcp/server';
import { verifyOrganizationToken } from '@/lib/mcp/tokens';
import { createClient } from '@supabase/supabase-js';

const SUPABASE_URL = process.env.SUPABASE_URL || 'http://localhost:8000';
const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY || '';

interface MCPRequest {
  jsonrpc: '2.0';
  id: number | string;
  method: string;
  params?: unknown;
}

interface MCPResponse {
  jsonrpc: '2.0';
  id: number | string;
  result?: unknown;
  error?: {
    code: number;
    message: string;
    data?: unknown;
  };
}

interface ToolCallParams {
  name: string;
  arguments?: Record<string, unknown>;
}

// List available tools
function handleListTools(): MCPResponse {
  return {
    jsonrpc: '2.0',
    id: 0,
    result: {
      tools: MCP_TOOLS,
    },
  };
}

// Call a specific tool
async function handleCallTool(
  id: number | string,
  params: ToolCallParams,
  orgId: string,
  userId: string
): Promise<MCPResponse> {
  try {
    const { name, arguments: args } = params;

    // Create admin client
    const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY);

    // Handle each tool
    switch (name) {
      // Account tools
      case 'list_projects': {
        const { data: projects } = await supabase
          .from('projects')
          .select('*, organizations(*)')
          .eq('organization_id', orgId);

        return {
          jsonrpc: '2.0',
          id,
          result: { projects },
        };
      }

      case 'get_project': {
        const project_ref = args?.project_ref as string;
        if (!project_ref) {
          throw new Error('project_ref is required');
        }

        const { data: project } = await supabase
          .from('projects')
          .select('*, project_databases(*)')
          .eq('id', project_ref)
          .eq('organization_id', orgId)
          .single();

        if (!project) {
          throw new Error('Project not found');
        }

        return {
          jsonrpc: '2.0',
          id,
          result: { project },
        };
      }

      case 'create_project': {
        const organization_id = args?.organization_id as string || orgId;
        const name = args?.name as string;
        const slug = args?.slug as string || name.toLowerCase().replace(/\s+/g, '-');
        const description = args?.description as string;

        const { data: project } = await supabase
          .from('projects')
          .insert({
            organization_id,
            name,
            slug,
            description,
            status: 'provisioning',
          })
          .select()
          .single();

        return {
          jsonrpc: '2.0',
          id,
          result: { project },
        };
      }

      case 'list_organizations': {
        const { data: orgs } = await supabase
          .from('organization_members')
          .select('organizations(*)')
          .eq('user_id', userId);

        return {
          jsonrpc: '2.0',
          id,
          result: { organizations: orgs?.map((o: unknown) => (o as { organizations: unknown }).organizations) },
        };
      }

      // Database tools
      case 'list_tables': {
        const project_ref = args?.project_ref as string;
        const schemas = (args?.schemas as string[]) || ['public'];

        if (!project_ref) {
          throw new Error('project_ref is required');
        }

        // Get project anon key
        const { data: project } = await supabase
          .from('projects')
          .select('anon_key, db_name')
          .eq('id', project_ref)
          .single();

        if (!project?.anon_key) {
          throw new Error('Project not found or not configured');
        }

        const projectClient = createClient(SUPABASE_URL, project.anon_key);

        const tables = [];
        for (const schema of schemas) {
          try {
            const { data: schemaTables } = await projectClient.rpc('get_tables', { schema_name: schema });
            tables.push(...(schemaTables || []));
          } catch {
            // Schema may not exist or function not available - skip
          }
        }

        return {
          jsonrpc: '2.0',
          id,
          result: { tables },
        };
      }

      case 'list_extensions': {
        const project_ref = args?.project_ref as string;

        if (!project_ref) {
          throw new Error('project_ref is required');
        }

        const { data: project } = await supabase
          .from('projects')
          .select('anon_key')
          .eq('id', project_ref)
          .single();

        if (!project?.anon_key) {
          throw new Error('Project not found or not configured');
        }

        const projectClient = createClient(SUPABASE_URL, project.anon_key);
        const { data: extensions } = await projectClient
          .from('pg_extension')
          .select('*')
          .order('extname');

        return {
          jsonrpc: '2.0',
          id,
          result: { extensions },
        };
      }

      case 'execute_sql': {
        const project_ref = args?.project_ref as string;
        const query = args?.query as string;

        if (!project_ref || !query) {
          throw new Error('project_ref and query are required');
        }

        const { data: project } = await supabase
          .from('projects')
          .select('anon_key')
          .eq('id', project_ref)
          .eq('organization_id', orgId)
          .single();

        if (!project?.anon_key) {
          throw new Error('Project not found or access denied');
        }

        const result = await executeProjectQuery(project_ref, query, project.anon_key);

        return {
          jsonrpc: '2.0',
          id,
          result,
        };
      }

      case 'generate_typescript_types': {
        const project_ref = args?.project_ref as string;
        const included_schemas = args?.included_schemas as string || 'public';

        if (!project_ref) {
          throw new Error('project_ref is required');
        }

        const { data: project } = await supabase
          .from('projects')
          .select('anon_key')
          .eq('id', project_ref)
          .eq('organization_id', orgId)
          .single();

        if (!project?.anon_key) {
          throw new Error('Project not found or access denied');
        }

        const types = await generateTypescriptTypes(project_ref, included_schemas, project.anon_key);

        return {
          jsonrpc: '2.0',
          id,
          result: { typescript_types: types },
        };
      }

      // Get publishable keys
      case 'get_publishable_keys': {
        const project_ref = args?.project_ref as string;

        if (!project_ref) {
          throw new Error('project_ref is required');
        }

        const { data: project } = await supabase
          .from('projects')
          .select('anon_key, service_role_key')
          .eq('id', project_ref)
          .eq('organization_id', orgId)
          .single();

        if (!project) {
          throw new Error('Project not found');
        }

        return {
          jsonrpc: '2.0',
          id,
          result: {
            keys: [
              {
                name: 'anon',
                key: project.anon_key,
              },
              {
                name: 'service_role',
                key: project.service_role_key,
              },
            ],
          },
        };
      }

      // Get project URL
      case 'get_project_url': {
        const project_ref = args?.project_ref as string;

        if (!project_ref) {
          throw new Error('project_ref is required');
        }

        const { data: project } = await supabase
          .from('projects')
          .select('slug')
          .eq('id', project_ref)
          .eq('organization_id', orgId)
          .single();

        if (!project) {
          throw new Error('Project not found');
        }

        return {
          jsonrpc: '2.0',
          id,
          result: {
            api_url: `${SUPABASE_URL.replace(':8000', '')}/api/projects/${project.slug}`,
            studio_url: `${SUPABASE_URL.replace(':8000', '')}/studio/${project.slug}`,
          },
        };
      }

      default:
        return {
          jsonrpc: '2.0',
          id,
          error: {
            code: -32601,
            message: `Tool not found: ${name}`,
          },
        };
    }
  } catch (error) {
    return {
      jsonrpc: '2.0',
      id,
      error: {
        code: -32603,
        message: error instanceof Error ? error.message : 'Unknown error',
      },
    };
  }
}

// Main MCP handler
export async function POST(request: NextRequest) {
  try {
    const body = (await request.json()) as MCPRequest;

    // Verify organization token
    const authHeader = request.headers.get('authorization');
    if (!authHeader?.startsWith('Bearer ')) {
      return NextResponse.json(
        {
          jsonrpc: '2.0',
          id: body.id,
          error: {
            code: -32600,
            message: 'Unauthorized: Missing or invalid authorization header',
          },
        } as MCPResponse,
        { status: 401 }
      );
    }

    const token = authHeader.substring(7);
    const payload = await verifyOrganizationToken(token);

    if (!payload) {
      return NextResponse.json(
        {
          jsonrpc: '2.0',
          id: body.id,
          error: {
            code: -32600,
            message: 'Unauthorized: Invalid token',
          },
        } as MCPResponse,
        { status: 401 }
      );
    }

    // Handle different MCP methods
    switch (body.method) {
      case 'initialize':
        return NextResponse.json({
          jsonrpc: '2.0',
          id: body.id,
          result: {
            protocolVersion: '2025-06-18',
            capabilities: {
              tools: {},
            },
            serverInfo: {
              name: 'nextmavens-mcp-server',
              version: '1.0.0',
            },
          },
        } as MCPResponse);

      case 'tools/list':
        return NextResponse.json(handleListTools());

      case 'tools/call': {
        const params = body.params as ToolCallParams;
        const response = await handleCallTool(
          body.id,
          params,
          payload.organization_id,
          payload.user_id
        );
        return NextResponse.json(response);
      }

      default:
        return NextResponse.json({
          jsonrpc: '2.0',
          id: body.id,
          error: {
            code: -32601,
            message: 'Method not found',
          },
        } as MCPResponse);
    }
  } catch (error) {
    return NextResponse.json(
      {
        jsonrpc: '2.0',
        id: 0,
        error: {
          code: -32700,
          message: 'Parse error',
        },
      } as MCPResponse,
      { status: 400 }
    );
  }
}

// OPTIONS for CORS
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  });
}
