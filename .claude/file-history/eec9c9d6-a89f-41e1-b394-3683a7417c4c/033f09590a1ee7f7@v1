// Studio Database Proxy
// Routes database requests from Studio to project-specific databases
// Based on project ID from cookie/header

const http = require('http');
const { Pool } = require('pg');

// Default database connection (master database)
const defaultPool = new Pool({
  host: process.env.DB_HOST || 'db',
  port: process.env.DB_PORT || 5432,
  database: process.env.DB_NAME || 'postgres',
  user: process.env.DB_USER || 'postgres',
  password: process.env.DB_PASSWORD || 'postgres',
});

// Project-specific connection pools cache
const projectPools = new Map();

// Get or create connection pool for a specific database
function getProjectPool(dbName) {
  if (!projectPools.has(dbName)) {
    const pool = new Pool({
      host: process.env.DB_HOST || 'db',
      port: process.env.DB_PORT || 5432,
      database: dbName,
      user: process.env.DB_USER || 'postgres',
      password: process.env.DB_PASSWORD || 'postgres',
    });
    projectPools.set(dbName, pool);
  }
  return projectPools.get(dbName);
}

// Parse project ID from request
function getProjectFromRequest(req) {
  // Try cookie first
  const cookies = req.headers.cookie || '';
  const cookieMatch = cookies.match(/studio_project=([^;]+)/);
  if (cookieMatch) {
    return cookieMatch[1];
  }

  // Try header
  const projectHeader = req.headers['x-studio-project'];
  if (projectHeader) {
    return projectHeader;
  }

  return null;
}

// Extract database name from project ID
async function getDatabaseForProject(projectId) {
  if (!projectId) return null;

  try {
    const result = await defaultPool.query(
      'SELECT db_name FROM projects WHERE id = $1',
      [projectId]
    );
    return result.rows[0]?.db_name || null;
  } catch (error) {
    console.error('Error getting database for project:', error);
    return null;
  }
}

// Create proxy server
const server = http.createServer(async (req, res) => {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    res.writeHead(200, {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Studio-Project',
      'Access-Control-Allow-Credentials': 'true',
    });
    res.end();
    return;
  }

  // Get project from request
  const projectId = getProjectFromRequest(req);
  let targetPool = defaultPool;

  // If project specified, try to get project-specific database
  if (projectId) {
    const dbName = await getDatabaseForProject(projectId);
    if (dbName) {
      targetPool = getProjectPool(dbName);
    }
  }

  // Handle health check
  if (req.url === '/health') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ status: 'ok', project: projectId }));
    return;
  }

  // Proxy PostgreSQL queries
  if (req.method === 'POST' && req.url === '/rpc') {
    let body = '';
    req.on('data', chunk => { body += chunk; });
    req.on('end', async () => {
      try {
        const query = JSON.parse(body);
        const result = await targetPool.query(query.text, query.values);

        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify(result.rows));
      } catch (error) {
        console.error('Query error:', error);
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: error.message }));
      }
    });
    return;
  }

  // Default response
  res.writeHead(404, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify({ error: 'Not found' }));
});

const PORT = process.env.PORT || 3001;
server.listen(PORT, () => {
  console.log(`Studio proxy running on port ${PORT}`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM received, closing pools');
  Promise.all([
    defaultPool.end(),
    ...Array.from(projectPools.values()).map(pool => pool.end()),
  ]).then(() => {
    process.exit(0);
  });
});
