#!/usr/bin/env node
/**
 * Pre-Task Hook: Validates MCP availability before spawning Maven Flow agents
 *
 * This hook runs before Task tool calls to Maven Flow specialist agents.
 * It validates that MCPs mentioned in the agent prompt are actually available.
 *
 * Usage: Called by Claude Code via PreToolUse hook
 *
 * Exit codes:
 * - 0: Allow the tool (validation passed or no MCPs needed)
 * - 3: Block the tool (required MCPs missing)
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Maven Flow specialist agent types
const MAVEN_FLOW_AGENTS = [
  'development-agent',
  'refactor-agent',
  'quality-agent',
  'security-agent',
  'design-agent'
];

// Common MCP server names
const COMMON_MCPS = [
  'supabase',
  'chrome-devtools',
  'web-search-prime',
  'web-reader',
  'playwright',
  'wrangler',
  'vercel',
  'figma',
  '4-5v-mcp',
  'memory-keeper',
  'filesystem'
];

// MCP patterns to extract from prompts
const MCP_PATTERNS = [
  /Use these MCPs?:?\s*([^\n]+)/i,
  /required MCPs?:?\s*([^\n]+)/i,
  /MCPs?:?\s*(?:available|required)?:?\s*([^\n]+)/i,
  /(?:use|with|using)\s+(?:the\s+)?(\w+(?:-\w+)*)\s+MCP/gi
];

/**
 * Extract MCP names from text using patterns
 */
function extractMCPsFromText(text) {
  if (!text) return new Set();

  const mcps = new Set();

  // Try each pattern
  for (const pattern of MCP_PATTERNS) {
    const matches = text.matchAll(pattern);
    for (const match of matches) {
      const mcpText = match[1] || match[0];
      // Split by commas, "and", spaces
      const names = mcpText
        .split(/[,;\s]+(?:and\s+)?/)
        .map(n => n.trim().toLowerCase())
        .filter(n => n && COMMON_MCPS.includes(n));
      names.forEach(n => mcps.add(n));
    }
  }

  return mcps;
}

/**
 * Get available MCPs from Claude Code settings
 */
function getAvailableMCPs(workingDir) {
  const availableMCPs = new Set();

  // Try to read Claude Code settings
  const possibleSettingsPaths = [
    path.join(workingDir, '.claude', 'settings.json'),
    path.join(os.homedir(), '.claude', 'settings.json'),
    path.join(os.homedir(), '.config', 'claude-code', 'settings.json')
  ];

  for (const settingsPath of possibleSettingsPaths) {
    try {
      if (fs.existsSync(settingsPath)) {
        const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf-8'));
        if (settings.mcpServers) {
          Object.keys(settings.mcpServers).forEach(mcpName => {
            availableMCPs.add(mcpName.toLowerCase());
          });
        }
        if (settings.mcp) {
          Object.keys(settings.mcp).forEach(mcpName => {
            availableMCPs.add(mcpName.toLowerCase());
          });
        }
      }
    } catch (e) {
      // Continue to next path
    }
  }

  // Also check CLAUDE_AVAILABLE_TOOLS env var if set
  if (process.env.CLAUDE_AVAILABLE_TOOLS) {
    try {
      const tools = JSON.parse(process.env.CLAUDE_AVAILABLE_TOOLS);
      // Tool names might be like "mcp__supabase__query"
      tools.forEach(tool => {
        const match = tool.match(/mcp__([^_]+)(?:__|$)/);
        if (match) {
          availableMCPs.add(match[1].toLowerCase());
        }
      });
    } catch (e) {
      // Ignore parse errors
    }
  }

  return availableMCPs;
}

/**
 * Get current working directory from hook input
 */
function getWorkingDir(input) {
  return input.cwd || process.cwd();
}

function main() {
  try {
    // Read JSON from STDIN (Claude Code hooks pass input via stdin)
    const stdinBuffer = fs.readFileSync(0, 'utf-8');
    let input;

    if (stdinBuffer.trim()) {
      try {
        input = JSON.parse(stdinBuffer);
      } catch (parseError) {
        // Input is not valid JSON, exit silently
        process.exit(0);
      }
    } else {
      // No input received, exit silently
      process.exit(0);
    }

    // Extract tool_input from the hook JSON structure
    const toolInput = input.tool_input || {};

    // Only validate Maven Flow agent spawns
    if (!toolInput.subagent_type || !MAVEN_FLOW_AGENTS.includes(toolInput.subagent_type)) {
      process.exit(0);
    }

    const workingDir = getWorkingDir(input);
    const prompt = toolInput.prompt || '';

    // Extract required MCPs from the prompt
    const requiredMCPs = extractMCPsFromText(prompt);

    // If no MCPs mentioned, allow (agent will use standard tools)
    if (requiredMCPs.size === 0) {
      process.exit(0);
    }

    // Get available MCPs
    const availableMCPs = getAvailableMCPs(workingDir);

    // Check for missing MCPs
    const missingMCPs = [...requiredMCPs].filter(mcp => !availableMCPs.has(mcp));

    if (missingMCPs.length > 0) {
      console.error(`\nâŒ MCP Validation Failed\n`);
      console.error(`The following required MCPs are not available:`);
      missingMCPs.forEach(mcp => {
        console.error(`  - ${mcp}`);
      });
      console.error(`\nAvailable MCPs in this environment:`);
      if (availableMCPs.size === 0) {
        console.error(`  (None detected)`);
      } else {
        [...availableMCPs].sort().forEach(mcp => {
          console.error(`  - ${mcp}`);
        });
      }
      console.error(`\nTo fix:`);
      console.error(`1. Install/configure the missing MCP servers`);
      console.error(`2. Or update the PRD to remove the missing MCP from mcpTools`);
      console.error(`3. Or update the prompt to not require that MCP\n`);
      process.exit(3); // Exit code 3 tells Claude to block the tool
    }

    // Validation passed
    process.exit(0);

  } catch (error) {
    // Log error but don't block execution
    // This prevents the hook from breaking the flow if something unexpected happens
    if (process.env.DEBUG) {
      console.error('Hook error:', error.message);
    }
    process.exit(0);
  }
}

// Polyfill for os.homedir() if needed
const os = require('os');

main();
