#!/usr/bin/env bash
#
# flow-convert - PRD Conversion and Maintenance Tool
#
# Two modes:
#   1. CONVERT: flow-convert <markdown-file> → converts MD to JSON
#   2. REPAIR:  flow-convert --fix <json-file> → validates/repairs existing JSON
#
# Usage:
#   flow-convert <markdown-file>              # Convert MD to JSON
#   flow-convert --fix <json-file>            # Repair existing JSON
#   flow-convert --validate-only <json-file>  # Validate only
#   flow-convert --all --fix                  # Repair all PRDs
#
# Flags:
#   --fix, --repair     - Repair/validate existing JSON PRDs
#   --validate-only     - Validate without modifying
#   --verbose           - Show detailed output
#   --all               - Process all PRDs in docs/
#   --force             - Reconvert existing JSON files (conversion mode)
#
# Exit codes:
#   0 - Success
#   1 - Validation failed
#   2 - Repair failed
#   3 - Lock acquisition failed
#   4 - File I/O error
#   5 - Invalid input

set -euo pipefail

# Source the lock library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOCK_LIB="${SCRIPT_DIR}/../.claude/lib/lock.sh"

if [ -f "$LOCK_LIB" ]; then
    source "$LOCK_LIB"
else
    echo "ERROR: Lock library not found at $LOCK_LIB" >&2
    exit 4
fi

# Default options
MODE=""  # Will be auto-detected: "convert" or "repair"
VALIDATE_ONLY=false
FORCE_REPAIR=false
VERBOSE=false
PROCESS_ALL=false
FORCE=false
DOCS_DIR="docs"
SESSION_ID="manual-$$"

# Colors for output (if terminal supports it)
if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m' # No Color
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

#
# Print colored message
#
log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_ok() {
    echo -e "${GREEN}[OK]${NC} $*"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

log_verbose() {
    if [ "$VERBOSE" = true ]; then
        echo -e "${BLUE}[VERBOSE]${NC} $*" >&2
    fi
}

#
# Show usage
#
show_usage() {
    cat <<EOF
flow-convert - PRD Conversion and Maintenance Tool

MODE 1: CONVERT (Markdown → JSON)
  flow-convert <markdown-file>

MODE 2: REPAIR/FIX (Validate & Repair existing JSON)
  flow-convert --fix <json-file>
  flow-convert --repair <json-file>

MODE 3: BATCH REPAIR
  flow-convert --all --fix

Arguments:
  markdown-file    - Path to markdown PRD file (e.g., "docs/prd-feature.md")
  json-file        - Path to JSON PRD file (e.g., "docs/prd-feature.json")
  feature-name     - Feature name (autodetects file type)

Flags:
  --fix, --repair     - Repair/validate existing JSON PRDs
  --validate-only     - Validate without modifying (repair mode)
  --verbose           - Show detailed output
  --all               - Process all PRDs in docs/ (repair mode)
  --help, -h          - Show this help message

Exit codes:
  0 - Success
  1 - Validation failed
  2 - Repair/conversion failed
  3 - Lock acquisition failed
  4 - File I/O error
  5 - Invalid input

Examples:
  # Convert markdown PRD to JSON
  flow-convert docs/prd-my-feature.md

  # Repair an existing JSON PRD
  flow-convert --fix docs/prd-my-feature.json

  # Validate a PRD without modifying
  flow-convert --fix --validate-only my-feature

  # Repair all JSON PRDs
  flow-convert --all --fix

  # Convert with verbose output
  flow-convert docs/prd-my-feature.md --verbose
EOF
}

#
# Parse command line flags
#
parse_flags() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --fix|--repair)
                MODE="repair"
                FORCE_REPAIR=true
                shift
                ;;
            --force-repair)
                # Alias for --fix (deprecated but kept for compatibility)
                MODE="repair"
                FORCE_REPAIR=true
                shift
                ;;
            --validate-only)
                VALIDATE_ONLY=true
                shift
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            --all)
                PROCESS_ALL=true
                shift
                ;;
            --force)
                FORCE=true
                shift
                ;;
            --help|-h)
                show_usage
                exit 0
                ;;
            -*)
                log_error "Unknown flag: $1"
                show_usage
                exit 5
                ;;
            *)
                # First non-flag argument is the target
                TARGET="$1"
                shift
                ;;
        esac
    done
}

#
# Get PRD file path from feature name or direct path
#
get_prd_path() {
    local input="$1"

    if [ -f "$input" ]; then
        # Direct file path
        echo "$input"
    elif [[ "$input" =~ ^prd-.*\.json$ ]]; then
        # PRD filename
        echo "${DOCS_DIR}/${input}"
    else
        # Feature name - construct PRD filename
        local kebab_case=$(echo "$input" | sed 's/\([A-Z]\)/-\L\1/g' | sed 's/^-//' | tr ' _' '-' '-')
        echo "${DOCS_DIR}/prd-${kebab_case}.json"
    fi
}

#
# Create backup of PRD file
#
create_backup() {
    local prd_file="$1"
    local timestamp=$(date +%Y%m%d-%H%M%S)
    local filename=$(basename "$prd_file")
    local backup_path="${prd_file}.bak-${timestamp}"

    if [ -f "$prd_file" ]; then
        cp "$prd_file" "$backup_path"
        log_verbose "Created backup: $backup_path"
        echo "$backup_path"
    else
        log_verbose "No file to backup: $prd_file"
        echo ""
    fi
}

#
# Restore from backup
#
restore_backup() {
    local prd_file="$1"
    local backup_path="$2"

    if [ -n "$backup_path" ] && [ -f "$backup_path" ]; then
        cp "$backup_path" "$prd_file"
        log_verbose "Restored from backup: $backup_path"
    fi
}

#
# Run validation on PRD
#
validate_prd() {
    local prd_file="$1"
    local verbose_flag="$([ "$VERBOSE" = true ] && echo "--verbose" || echo "")"

    log_info "Validating: $prd_file"

    # Use Node.js to run validation
    local result=$(node -e "
        const prdUtils = require('${SCRIPT_DIR}/../.claude/hooks/prd-utils.js');
        const result = prdUtils.validateSchema('${prd_file}', {verbose: ${VERBOSE}});
        console.log(JSON.stringify(result));
    " 2>&1)

    if [ $? -ne 0 ]; then
        log_error "Validation execution failed: $result"
        return 1
    fi

    # Parse result
    local valid=$(echo "$result" | jq -r '.valid // false')
    local errors=$(echo "$result" | jq -r '.errors // []' | jq -r '.[]' 2>/dev/null || echo "")
    local warnings=$(echo "$result" | jq -r '.warnings // []' | jq -r '.[]' 2>/dev/null || echo "")

    if [ "$valid" = "true" ]; then
        log_ok "Validation passed"
        if [ -n "$warnings" ]; then
            while IFS= read -r warning; do
                log_warn "$warning"
            done <<< "$warnings"
        fi
        return 0
    else
        log_error "Validation failed"
        while IFS= read -r error; do
            log_error "  - $error"
        done <<< "$errors"
        return 1
    fi
}

#
# Run repair on PRD
#
repair_prd() {
    local prd_file="$1"
    local dry_run="$([ "$FORCE_REPAIR" = false ] && echo "true" || echo "false")"

    log_info "Repairing: $prd_file (dry-run: $dry_run)"

    # Use Node.js to run repair
    local result=$(node -e "
        const prdUtils = require('${SCRIPT_DIR}/../.claude/hooks/prd-utils.js');
        const result = prdUtils.repairPRD('${prd_file}', {
            verbose: ${VERBOSE},
            dryRun: ${dry_run}
        });
        console.log(JSON.stringify(result));
    " 2>&1)

    if [ $? -ne 0 ]; then
        log_error "Repair execution failed: $result"
        return 2
    fi

    # Parse result
    local success=$(echo "$result" | jq -r '.success // false')
    local repairs=$(echo "$result" | jq -r '.repairs // []')
    local message=$(echo "$result" | jq -r '.message // ""')
    local error=$(echo "$result" | jq -r '.error // ""')

    if [ "$success" = "true" ]; then
        log_ok "Repair completed"

        # Show repairs made
        local repair_count=$(echo "$repairs" | jq 'length')
        if [ "$repair_count" -gt 0 ]; then
            log_info "Repairs made ($repair_count):"
            echo "$repairs" | jq -r '.[]' | while IFS= read -r repair; do
                echo "  - $repair"
            done
        fi

        if [ -n "$message" ]; then
            log_info "$message"
        fi

        return 0
    else
        log_error "Repair failed: $error"
        return 2
    fi
}

#
# Run memory sync on PRD
#
sync_memory() {
    local prd_file="$1"

    log_info "Syncing memory: $prd_file"

    # Use Node.js to run sync
    local result=$(node -e "
        const prdUtils = require('${SCRIPT_DIR}/../.claude/hooks/prd-utils.js');
        const result = prdUtils.syncMemory('${prd_file}', {
            verbose: ${VERBOSE},
            docsDir: '${DOCS_DIR}'
        });
        console.log(JSON.stringify(result));
    " 2>&1)

    if [ $? -ne 0 ]; then
        log_warn "Memory sync execution failed: $result"
        return 0  # Don't fail on sync errors
    fi

    # Parse result
    local success=$(echo "$result" | jq -r '.success // false')
    local sync_results=$(echo "$result" | jq -r '.syncResults // []')

    if [ "$success" = "true" ]; then
        log_ok "Memory sync completed"

        # Show sync results
        echo "$sync_results" | jq -r '.[]' 2>/dev/null | while IFS= read -r result; do
            local status=$(echo "$result" | jq -r '.status // "info"' 2>/dev/null)
            local message=$(echo "$result" | jq -r '.message // ""' 2>/dev/null)
            local prd=$(echo "$result" | jq -r '.prd // ""' 2>/dev/null)

            case "$status" in
                warning)
                    log_warn "$message"
                    ;;
                error)
                    log_error "$message"
                    ;;
                *)
                    if [ -n "$prd" ]; then
                        log_info "[$prd] $message"
                    else
                        log_info "$message"
                    fi
                    ;;
            esac
        done

        return 0
    else
        local error=$(echo "$result" | jq -r '.error // ""')
        log_warn "Memory sync failed: $error"
        return 0  # Don't fail on sync errors
    fi
}

#
# Process a single PRD
#
process_prd() {
    local prd_file="$1"
    local backup_path=""
    local exit_code=0

    log_info "==============================================================================="
    log_info "Processing: $prd_file"
    log_info "==============================================================================="

    # Check if file exists
    if [ ! -f "$prd_file" ]; then
        log_error "PRD file not found: $prd_file"
        return 4
    fi

    # Acquire PRD lock
    log_verbose "Acquiring lock for: $prd_file"
    if ! acquire_prd_lock "$prd_file" "$SESSION_ID"; then
        log_error "Failed to acquire lock for $prd_file"
        return 3
    fi

    # Create backup before any modifications
    if [ "$VALIDATE_ONLY" = false ] || [ "$FORCE_REPAIR" = true ]; then
        backup_path=$(create_backup "$prd_file")
    fi

    # STEP 1: Validate
    log_info "Step 1: Validating schema..."
    if ! validate_prd "$prd_file"; then
        local validation_failed=$?

        # If validate-only mode, exit now
        if [ "$VALIDATE_ONLY" = true ]; then
            release_prd_lock "$prd_file" "$SESSION_ID"
            return 1
        fi

        # If force-repair, continue to repair step
        if [ "$FORCE_REPAIR" = false ]; then
            log_error "Validation failed. Use --force-repair to auto-fix issues."
            release_prd_lock "$prd_file" "$SESSION_ID"
            return 1
        fi
    fi

    # STEP 2: Repair (if force-repair)
    if [ "$FORCE_REPAIR" = true ]; then
        log_info "Step 2: Repairing issues..."
        if ! repair_prd "$prd_file"; then
            local repair_failed=$?
            # Restore from backup on failure
            restore_backup "$prd_file" "$backup_path"
            release_prd_lock "$prd_file" "$SESSION_ID"
            return 2
        fi
    fi

    # STEP 3: Memory sync
    log_info "Step 3: Syncing memory..."
    sync_memory "$prd_file"  # Don't fail on sync errors

    # Release lock
    release_prd_lock "$prd_file" "$SESSION_ID"

    # Summary
    log_info "==============================================================================="
    log_ok "Completed: $prd_file"
    if [ -n "$backup_path" ]; then
        log_info "Backup: $backup_path"
    fi
    log_info "==============================================================================="

    return 0
}

#
# Process all PRDs in docs directory
#
process_all_prds() {
    log_info "Processing all PRDs in ${DOCS_DIR}/"

    # Find all PRD files
    local prd_files=()
    while IFS= read -r -d '' file; do
        prd_files+=("$file")
    done < <(find "${DOCS_DIR}" -name "prd-*.json" -type f -print0 2>/dev/null | sort -z)

    if [ ${#prd_files[@]} -eq 0 ]; then
        log_warn "No PRD files found in ${DOCS_DIR}/"
        return 0
    fi

    log_info "Found ${#prd_files[@]} PRD file(s)"

    local total=0
    local passed=0
    local failed=0

    for prd_file in "${prd_files[@]}"; do
        total=$((total + 1))
        if process_prd "$prd_file"; then
            passed=$((passed + 1))
        else
            failed=$((failed + 1))
        fi
        echo ""
    done

    # Final summary
    log_info "==============================================================================="
    log_info "SUMMARY: All PRDs Processed"
    log_info "==============================================================================="
    log_info "Total:  $total"
    log_ok "Passed: $passed"
    if [ $failed -gt 0 ]; then
        log_error "Failed: $failed"
    fi
    log_info "==============================================================================="

    [ $failed -eq 0 ]
}

#
# Convert markdown PRD to JSON (triggers the skill)
#
convert_prd() {
    local md_file="$1"

    log_info "==============================================================================="
    log_info "CONVERT MODE: Markdown → JSON"
    log_info "==============================================================================="
    log_info "Input: $md_file"

    # Check if file exists
    if [ ! -f "$md_file" ]; then
        log_error "Markdown file not found: $md_file"
        exit 4
    fi

    # Read the markdown content
    local md_content=$(cat "$md_file")

    log_info ""
    log_info "Triggering flow-convert skill to convert PRD..."
    log_info ""
    log_info "To complete the conversion, run in Claude Code:"
    log_info "  convert this prd"
    log_info ""
    log_info "Or use the Skill tool with:"
    log_info "  /flow-convert"
    log_info ""

    # If claude command is available, try to invoke it
    if command -v claude &>/dev/null; then
        log_info "Invoking Claude Code..."
        echo "$md_content" | claude skill flow-convert
    else
        log_warn "Claude Code CLI not found. Please run the conversion manually in Claude Code."
        log_info "You can paste this prompt:"
        echo ""
        echo "----------------------------------------"
        cat "$md_file"
        echo "----------------------------------------"
        echo ""
        log_info "Then say: convert this prd"
    fi
}

#
# Main execution
#
main() {
    # Parse flags
    parse_flags "$@"

    # Auto-detect mode if not explicitly set
    if [ -z "$MODE" ] && [ -n "${TARGET:-}" ]; then
        if [[ "$TARGET" =~ \.md$ ]]; then
            MODE="convert"
        elif [[ "$TARGET" =~ \.json$ ]] || [ "$VALIDATE_ONLY" = true ] || [ "$FORCE_REPAIR" = true ]; then
            MODE="repair"
        fi
    fi

    # Show mode if verbose
    log_verbose "Mode: $MODE"
    log_verbose "Target: $TARGET"

    # Convert mode
    if [ "$MODE" = "convert" ]; then
        if [ -z "${TARGET:-}" ]; then
            log_error "No markdown file specified"
            show_usage
            exit 5
        fi
        convert_prd "$TARGET"
        exit $?
    fi

    # Repair mode
    if [ "$MODE" = "repair" ] || [ -z "$MODE" ]; then
        # Check if docs directory exists
        if [ ! -d "$DOCS_DIR" ]; then
            log_error "Docs directory not found: $DOCS_DIR"
            log_info "Create it with: mkdir -p $DOCS_DIR"
            exit 4
        fi

        # Process all or single PRD
        if [ "$PROCESS_ALL" = true ]; then
            process_all_prds
            exit $?
        else
            if [ -z "${TARGET:-}" ]; then
                log_error "No target specified"
                show_usage
                exit 5
            fi

            local prd_path=$(get_prd_path "$TARGET")
            process_prd "$prd_path"
            exit $?
        fi
    fi

    # No mode detected
    log_error "Could not determine mode. Please specify:"
    log_error "  - A .md file for conversion, or"
    log_error "  - Use --fix flag for repair mode"
    show_usage
    exit 5
}

# Run main if script is executed directly
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    main "$@"
fi
