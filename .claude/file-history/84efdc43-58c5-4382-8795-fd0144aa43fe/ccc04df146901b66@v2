/**
 * Database Module - Query builder for REST API
 */

import { Filter, OrderBy, QueryOptions, InsertData, UpdateData, DatabaseError, NextMavensConfig } from './types';

export class DatabaseClient {
  private config: Required<NextMavensConfig>;

  constructor(config: NextMavensConfig) {
    this.config = {
      apiKey: config.apiKey,
      apiUrl: config.apiUrl || 'https://api.nextmavens.cloud',
      authUrl: config.authUrl || 'https://auth.nextmavens.cloud',
      graphqlUrl: config.graphqlUrl || 'https://graphql.nextmavens.cloud',
      realtimeUrl: config.realtimeUrl || 'wss://realtime.nextmavens.cloud',
      storageUrl: config.storageUrl || 'https://telegram.nextmavens.cloud'
    };
  }

  /**
   * Create a query builder for a table
   */
  from<T = any>(table: string): QueryBuilder<T> {
    return new QueryBuilder<T>(table, this.config);
  }

  /**
   * Insert a row into a table
   */
  async insert<T = any>(table: string, data: InsertData): Promise<{ data: T }> {
    try {
      const response = await fetch(`${this.config.apiUrl}/${table}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': this.config.apiKey
        },
        body: JSON.stringify(data)
      });

      const result = await response.json();

      if (!response.ok) {
        throw new DatabaseError(result.error || 'Insert failed', 'INSERT_FAILED');
      }

      return result;
    } catch (error) {
      if (error instanceof DatabaseError) throw error;
      throw new DatabaseError('Insert failed', 'NETWORK_ERROR');
    }
  }

  /**
   * Update rows in a table
   */
  async update<T = any>(table: string, data: UpdateData, filters?: Filter[]): Promise<{ data: T[] }> {
    const builder = this.from<T>(table);

    if (filters) {
      filters.forEach(f => builder.filter(f.column, f.operator, f.value));
    }

    return builder.update(data);
  }

  /**
   * Delete rows from a table
   */
  async delete(table: string, filters: Filter[]): Promise<void> {
    const builder = this.from(table);

    filters.forEach(f => builder.filter(f.column, f.operator, f.value));

    return builder.delete();
  }
}

/**
 * Query Builder for fluent database queries
 */
export class QueryBuilder<T = any> {
  private table: string;
  private config: NextMavensConfig;
  private selectColumns: string[] = [];
  private filters: Filter[] = [];
  private orderByClause: OrderBy | null = null;
  private limitValue: number | null = null;
  private offsetValue: number | null = null;

  constructor(table: string, config: NextMavensConfig) {
    this.table = table;
    this.config = config;
  }

  /**
   * Select specific columns
   */
  select(...columns: string[]): this {
    this.selectColumns = columns;
    return this;
  }

  /**
   * Add a filter
   */
  filter(column: string, operator: Filter['operator'], value: any): this {
    this.filters.push({ column, operator, value });
    return this;
  }

  /**
   * Add equality filter (shortcut)
   */
  eq(column: string, value: any): this {
    return this.filter(column, 'eq', value);
  }

  /**
   * Add not equal filter (shortcut)
   */
  neq(column: string, value: any): this {
    return this.filter(column, 'neq', value);
  }

  /**
   * Add greater than filter (shortcut)
   */
  gt(column: string, value: any): this {
    return this.filter(column, 'gt', value);
  }

  /**
   * Add greater than or equal filter (shortcut)
   */
  gte(column: string, value: any): this {
    return this.filter(column, 'gte', value);
  }

  /**
   * Add less than filter (shortcut)
   */
  lt(column: string, value: any): this {
    return this.filter(column, 'lt', value);
  }

  /**
   * Add less than or equal filter (shortcut)
   */
  lte(column: string, value: any): this {
    return this.filter(column, 'lte', value);
  }

  /**
   * Add LIKE filter (shortcut)
   */
  like(column: string, value: string): this {
    return this.filter(column, 'like', value);
  }

  /**
   * Add ILIKE filter (case-insensitive, shortcut)
   */
  ilike(column: string, value: string): this {
    return this.filter(column, 'ilike', value);
  }

  /**
   * Add IN filter (shortcut)
   */
  in(column: string, values: any[]): this {
    return this.filter(column, 'in', values);
  }

  /**
   * Add IS NULL filter (shortcut)
   */
  isNull(column: string): this {
    return this.filter(column, 'is', null);
  }

  /**
   * Add IS NOT NULL filter (shortcut)
   */
  isNotNull(column: string): this {
    return this.filter(column, 'is', 'not_null');
  }

  /**
   * Order results
   */
  orderBy(column: string, ascending: boolean = true): this {
    this.orderByClause = { column, ascending };
    return this;
  }

  /**
   * Order ascending (shortcut)
   */
  asc(column: string): this {
    return this.orderBy(column, true);
  }

  /**
   * Order descending (shortcut)
   */
  desc(column: string): this {
    return this.orderBy(column, false);
  }

  /**
   * Limit results
   */
  limit(limit: number): this {
    this.limitValue = limit;
    return this;
  }

  /**
   * Offset results
   */
  offset(offset: number): this {
    this.offsetValue = offset;
    return this;
  }

  /**
   * Execute the query and get results
   */
  async execute(): Promise<T[]> {
    try {
      const url = this.buildUrl();
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': this.config.apiKey
        }
      });

      const result = await response.json();

      if (!response.ok) {
        throw new DatabaseError(result.error || 'Query failed', 'QUERY_FAILED');
      }

      // Handle different response formats
      if (Array.isArray(result)) {
        return result;
      } else if (result.data) {
        return result.data;
      } else if (result.results) {
        return result.results;
      }

      return result;
    } catch (error) {
      if (error instanceof DatabaseError) throw error;
      throw new DatabaseError('Query failed', 'NETWORK_ERROR');
    }
  }

  /**
   * Get a single result (throws if not found)
   */
  async single(): Promise<T> {
    const results = await this.limit(1).execute();

    if (results.length === 0) {
      throw new DatabaseError('No results found', 'NOT_FOUND');
    }

    return results[0];
  }

  /**
   * Get first result or null if not found
   */
  async first(): Promise<T | null> {
    const results = await this.limit(1).execute();
    return results.length > 0 ? results[0] : null;
  }

  /**
   * Count results
   */
  async count(): Promise<number> {
    // This would need a specific count endpoint or we can count locally
    const results = await this.execute();
    return results.length;
  }

  /**
   * Check if any results exist
   */
  async exists(): Promise<boolean> {
    const results = await this.limit(1).execute();
    return results.length > 0;
  }

  /**
   * Update rows matching the query
   */
  async update(data: UpdateData): Promise<{ data: T[] }> {
    try {
      const url = this.buildUrl();
      const response = await fetch(url, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': this.config.apiKey
        },
        body: JSON.stringify(data)
      });

      const result = await response.json();

      if (!response.ok) {
        throw new DatabaseError(result.error || 'Update failed', 'UPDATE_FAILED');
      }

      return result;
    } catch (error) {
      if (error instanceof DatabaseError) throw error;
      throw new DatabaseError('Update failed', 'NETWORK_ERROR');
    }
  }

  /**
   * Delete rows matching the query
   */
  async delete(): Promise<void> {
    try {
      const url = this.buildUrl();
      const response = await fetch(url, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': this.config.apiKey
        }
      });

      if (!response.ok) {
        const result = await response.json();
        throw new DatabaseError(result.error || 'Delete failed', 'DELETE_FAILED');
      }
    } catch (error) {
      if (error instanceof DatabaseError) throw error;
      throw new DatabaseError('Delete failed', 'NETWORK_ERROR');
    }
  }

  /**
   * Build the URL with query parameters
   */
  private buildUrl(): string {
    let url = `${this.config.apiUrl}/${this.table}`;

    const params = new URLSearchParams();

    // Add select columns
    if (this.selectColumns.length > 0) {
      params.append('select', this.selectColumns.join(','));
    }

    // Add filters
    this.filters.forEach(f => {
      const key = `${f.column}`;
      const value = typeof f.value === 'object' ? JSON.stringify(f.value) : String(f.value);

      switch (f.operator) {
        case 'eq':
          params.append(key, value);
          break;
        case 'neq':
          params.append(`${key}.neq`, value);
          break;
        case 'gt':
          params.append(`${key}.gt`, value);
          break;
        case 'gte':
          params.append(`${key}.gte`, value);
          break;
        case 'lt':
          params.append(`${key}.lt`, value);
          break;
        case 'lte':
          params.append(`${key}.lte`, value);
          break;
        case 'like':
          params.append(`${key}.like`, value);
          break;
        case 'ilike':
          params.append(`${key}.ilike`, value);
          break;
        case 'in':
          params.append(`${key}.in`, value);
          break;
        case 'is':
          params.append(`${key}.is`, value);
          break;
      }
    });

    // Add order by
    if (this.orderByClause) {
      const order = this.orderByClause.ascending ? 'asc' : 'desc';
      params.append('order', `${this.orderByClause.column}.${order}`);
    }

    // Add limit
    if (this.limitValue !== null) {
      params.append('limit', String(this.limitValue));
    }

    // Add offset
    if (this.offsetValue !== null) {
      params.append('offset', String(this.offsetValue));
    }

    const queryString = params.toString();
    if (queryString) {
      url += `?${queryString}`;
    }

    return url;
  }
}
