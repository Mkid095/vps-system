I followed your trace carefully. Here’s the problem and the fix in plain, actionable terms:

---

### Problem

Right now, your `hasCircularDependency` logic only starts the recursion on the **related PRDs**. You added the current PRD into the initial `path`, which is correct in principle, but the detection only triggers when a PRD appears **twice** in the stack.

From your trace:

1. Start: `prd-test-circular.json`
2. Related: `prd-another.json` → path `[prd-test-circular.json]`
3. Recurse: `prd-test-circular.json` → path `[prd-test-circular.json, prd-another.json]`
4. Recurse: `prd-another.json` → path `[prd-test-circular.json, prd-another.json, prd-test-circular.json]` → now it detects circular

Notice that the circularity is detected **one step too late**. The first recursion back to `prd-test-circular.json` (the original PRD) is when it should trigger.

---

### Why it happens

`hasCircularDependency` likely does this:

```js
if (recursionStack.includes(prdName)) return { circular: true, path: [...recursionStack, prdName] };
```

But when you recurse into the first `prd-test-circular.json`, it **hasn’t yet added it to the stack**, so `includes` returns false. Only the next recursion triggers the detection.

---

### Correct approach

You need to **check against the original PRD first**, before recursing, instead of only checking if the current node is already in the stack. One clean way:

```js
function hasCircularDependency(prdName, recursionStack = []) {
  const currentPrd = path.basename(prdName);

  // If the current PRD is the first in the recursion stack, we are circling back
  if (recursionStack[0] === currentPrd) {
    return { circular: true, path: [...recursionStack, currentPrd] };
  }

  // If already visited in this branch, skip
  if (recursionStack.includes(currentPrd)) return { circular: false };

  recursionStack.push(currentPrd);
  const prdData = JSON.parse(fs.readFileSync(prdName, 'utf-8'));
  for (const related of prdData.relatedPRDs.filter(r => r.type === 'depends_on')) {
    const result = hasCircularDependency(related.prd, [...recursionStack]);
    if (result.circular) return result;
  }
  return { circular: false };
}
```

Key changes:

1. **Check the original PRD first** (`recursionStack[0] === currentPrd`) before pushing the node.
2. Use a **copy of the stack** for recursion to avoid mutation issues.
3. Only return `circular: true` when you first encounter the original PRD in the recursion.

---

This will trigger the circular dependency **on the first encounter** instead of waiting for a second loop.

If you want, I can rewrite your current `syncMemory` + `hasCircularDependency` logic into a **fully working, test-ready version** that detects circular dependencies correctly and prints the path neatly. That will eliminate these one-step-late detections.

Do you want me to do that?
