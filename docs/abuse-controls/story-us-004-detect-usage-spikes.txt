STORY MEMORY: US-004 - Detect Usage Spikes
=========================================================

COMPLETED: 2026-01-28

STORY DETAILS:
- ID: US-004
- Title: Detect Usage Spikes
- Priority: 2
- Maven Steps: [1, 2, 7, 10]
- Status: Complete

IMPLEMENTATION SUMMARY:
Implemented usage spike detection system that calculates average usage per project and detects anomalous behavior (3x+ average). System includes three severity levels (WARNING 3x-5x, CRITICAL 5x-10x, SEVERE 10x+), configurable thresholds, automatic suspension on critical/severe spikes, background job for periodic checks, and comprehensive audit logging.

FILES CREATED (13):
- src/features/abuse-controls/lib/spike-detection.ts (650+ lines) - Core spike detection library with calculateAverageUsage(), detectUsageSpike(), checkProjectForSpikes(), runSpikeDetection(), triggerSpikeAction()
- src/features/abuse-controls/lib/spike-config.ts (80+ lines) - Spike detection configuration management
- src/features/abuse-controls/migrations/create-usage-metrics-table.ts (100+ lines) - Database migration for usage_metrics table
- src/features/abuse-controls/migrations/create-spike-detection-config-table.ts (120+ lines) - Database migration for spike_detection_config table
- src/features/abuse-controls/migrations/create-spike-detections-table.ts (150+ lines) - Database migration for spike_detections audit table
- scripts/migrate-spike-detection.ts (30+ lines) - Migration runner script
- src/app/api/admin/spike-detection/check/route.ts (100+ lines) - Admin API endpoint for manual spike detection checks
- src/features/abuse-controls/US-004-SECURITY-AUDIT-REPORT.md (200+ lines) - Comprehensive security audit documentation

FILES MODIFIED (4):
- src/features/abuse-controls/types/index.ts - Added SpikeSeverity enum, SpikeDetectionJobResult interface
- src/features/abuse-controls/lib/config.ts - Added spike severity thresholds and configuration
- src/features/abuse-controls/lib/data-layer.ts - Added SpikeDetectionManager class
- src/features/abuse-controls/index.ts - Exported spike detection types and functions

KEY DECISIONS:
1. Three-tier severity system (WARNING, CRITICAL, SEVERE)
   - Rationale: Different spike levels require different responses
   - Impact: WARNING logs only, CRITICAL/SEVERE trigger suspension
   - Configuration: 3x-5x = WARNING, 5x-10x = CRITICAL, 10x+ = SEVERE

2. PostgreSQL for spike detection storage
   - Rationale: Existing infrastructure, keeps data centralized
   - Impact: Persistent detection history, queryable for analytics

3. Per-project configurable thresholds
   - Rationale: Different projects have different usage patterns
   - Impact: spike_detection_config table allows customization per project

4. Minimum usage threshold (10 events)
   - Rationale: Prevent false positives on low-usage projects
   - Impact: Spikes only detected when baseline usage is significant

5. Background job as library function
   - Rationale: Allows flexible scheduling (cron, cloud scheduler)
   - Impact: runSpikeDetection() can be called by any scheduler

INTEGRATION POINTS:
- Suspension System (US-003): Uses suspendProject() for CRITICAL and SEVERE spikes
- Quota Manager (US-001): Uses quota types for metric categorization
- Audit Logging: Logs all spike detections and actions
- Database (@/lib/db): Uses existing PostgreSQL connection pool
- Background scheduler: runSpikeDetection() ready to be called by external cron/scheduler

CHALLENGES RESOLVED:
1. Baseline calculation for new projects
   - Problem: New projects have no historical usage data
   - Solution: Minimum usage threshold prevents false positives
   - Lesson: Need minimum thresholds for statistical significance

2. Determining appropriate action per severity
   - Problem: Which spikes should suspend vs warn?
   - Solution: Configurable action mapping (WARNING=none, CRITICAL=suspend, SEVERE=suspend)
   - Lesson: Severity thresholds should be configurable per environment

3. Performance of aggregate queries
   - Problem: Calculating averages across all projects could be slow
   - Solution: Proper indexes on (project_id, metric_type, window_start)
   - Lesson: Database indexing critical for time-series aggregation queries

LESSONS LEARNED:
1. Spike detection requires historical data - need to build usage tracking first or accept cold start period
2. Severity levels provide flexible response options - not all spikes require suspension
3. Per-project configuration is essential - one size doesn't fit all for usage patterns
4. Background job as library function provides flexibility - can be scheduled via cron, cloud scheduler, or manual
5. Audit logging is critical even for automated systems - need trail of why projects were suspended
6. Minimum thresholds prevent false positives on low-volume projects

CODE PATTERNS ESTABLISHED:

Pattern 1: Spike Detection Algorithm
```typescript
export async function detectUsageSpike(
  projectId: string,
  metricType: MetricType,
  thresholdMultiplier: number
): Promise<UsageSpikeDetection | null> {
  const currentUsage = await getCurrentUsage(projectId, metricType)
  const averageUsage = await calculateAverageUsage(projectId, metricType)
  const multiplier = averageUsage > 0 ? currentUsage / averageUsage : 0

  if (multiplier >= thresholdMultiplier && currentUsage >= MIN_USAGE_THRESHOLD) {
    const severity = determineSpikeSeverity(multiplier)
    return { isSpike: true, multiplier, severity, currentUsage, averageUsage }
  }
  return { isSpike: false, multiplier, currentUsage, averageUsage }
}
```
- Usage: For detecting anomalous usage patterns
- Benefits: Statistical baseline comparison, severity classification

Pattern 2: Background Job with Statistics
```typescript
export async function runSpikeDetection(): Promise<SpikeDetectionJobResult> {
  const startTime = new Date()
  const projects = await getAllActiveProjects()
  let spikesDetected = 0

  for (const project of projects) {
    const spikes = await checkProjectForSpikes(project.id)
    spikesDetected += spikes.length
  }

  return { success: true, startTime, endTime: new Date(), projectsChecked, spikesDetected }
}
```
- Usage: For background operations that need detailed results
- Benefits: Testable, returns statistics, can be called manually

Pattern 3: Severity-Based Action Mapping
```typescript
export async function triggerSpikeAction(
  projectId: string,
  spike: UsageSpikeDetection
): Promise<void> {
  switch (spike.severity) {
    case SpikeSeverity.WARNING:
      await logAuditEvent({ eventType: 'spike_warning', projectId, ... })
      break
    case SpikeSeverity.CRITICAL:
    case SpikeSeverity.SEVERE:
      await suspendProject(projectId, reason)
      break
  }
}
```
- Usage: For severity-based response logic
- Benefits: Configurable responses per severity level

ACCEPTANCE CRITERIA:
- Job calculates average usage per project - VERIFIED: calculateAverageUsage() in spike-detection.ts
- Detects 3x average for 1 hour - VERIFIED: DEFAULT_THRESHOLD_MULTIPLIER = 3.0, default window 60 minutes
- Triggers warning or suspension - VERIFIED: triggerSpikeAction() suspends CRITICAL/SEVERE, warns WARNING
- Threshold configurable - VERIFIED: spike_detection_config table allows per-project configuration
- Typecheck passes - VERIFIED: pnpm run typecheck completed with no errors

NEXT STORY DEPENDENCIES:
- US-005 (Detect Error Rate Spikes) can reuse spike detection patterns
- US-006 (Detect Malicious Patterns) can integrate with spike detection for enhanced detection
- US-007 (Send Suspension Notifications) will use spike detection events for alerts
- Future: Real usage tracking integration (currently placeholder getCurrentUsage())

ARCHITECTURAL NOTES:
- Spike detection is independent of quota system but uses same metric types
- Background job is decoupled from scheduler - can be called by cron, cloud scheduler, or manually
- Severity levels provide flexible response - not all spikes result in suspension
- System requires historical usage data - cold start period for new projects
- All detection operations use transactions for consistency
- System assumes project_id is the primary identifier for spike detection associations
